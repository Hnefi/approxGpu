/********************************
Author: Sravanthi Kota Venkata
********************************/

// Mark Sutherland, Joshua San Miguel
//  - University of Toronto

// Call a fast GPU implementation to blur this image.

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <ctype.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <time.h>
#include <sys/time.h>
#include "sdvbs_common.h"

F2D* imageBlur(I2D* imageIn)
{
    int rows, cols;
    F2D *imageOut, *tempOut;
    float temp;
    I2D *kernel;
    int k, kernelSize, startCol, endCol, halfKernel, startRow, endRow, i, j, kernelSum;

    rows = imageIn->height;
    cols = imageIn->width;

    //imageOut = fSetArray(rows, cols, 0);
    //tempOut = fSetArray(rows, cols, 0);
    //kernel = iMallocHandle(1, 5); // 1 row, 5 columns of kernel (NON SQUARE)

    asubsref(kernel,0) = 1; //kernel->data[0] = 1;
    asubsref(kernel,1) = 4;
    asubsref(kernel,2) = 6;
    asubsref(kernel,3) = 4;
    asubsref(kernel,4) = 1;
    kernelSize = 5;
    kernelSum = 16;

    startCol = 2;  
    endCol = cols - 2;  
    halfKernel = 2;   

    startRow = 2;    
    endRow = rows - 2;  
   
    dim3 nblocks(4,3);
    dim3 threadsPerBlock(32,32);
    char* d_inputPixels;
    char* d_outputPixels;
    cudaMalloc((void**)&d_inputPixels,rows*cols*3);
    cudaMalloc((void**)&d_inputPixels,rows*cols*3);
    cudaMemcpy(d_inputPixels,&(imageIn->data[0]),rows*cols*3,cudaMemcpyHostToDevice);
    cudaMemset(d_outputPixels,0,rows*cols*3);

    /* Kernel call */
    weightedBlurKernel<<<nblocks,threadsPerBlock>>>((char3*)d_inputPixels,(char3*) d_outputPixels,rows,cols);

    char* outputPixels = (char*)malloc(height*width*3);
    cudaMemcpy(outputPixels,d_outputPixels,rows*cols*3,cudaMemcpyDeviceToHost);

    // deep copy into imageOut structure
    I2D* tmpStructure = iSetArray(rows,cols,0);
    memcpy(&(tmpStructure->data[0]),&(outputPixels->data[0]),rows*cols);
    F2D* imageOut = fiDeepCopy(tmpStructure);
    iFreeHandle(tmpStructure);
    return imageOut;
    //fFreeHandle(tempOut);
    //iFreeHandle(kernel);
#ifdef APPROXIMATE
    // approximate all of the image data. NOTE: NOT THE KERNEL
    LVA_FUNCTION(2 /* int */, &(imageIn->data[0]),&(imageIn->data[rows*cols]),1);
    LVA_FUNCTION(5/*float*/, &(tempOut->data[0]),&(tempOut->data[rows*cols]),1);
    LVA_FUNCTION(5/*float*/, &(imageOut->data[0]),&(imageOut->data[rows*cols]),1);
#endif
/*
    for(i=startRow; i<endRow; i++){
        for(j=startCol; j<endCol; j++)
        {
            temp = 0;
            for(k=-halfKernel; k<=halfKernel; k++)
            {
                temp += subsref(imageIn,i,j+k) * asubsref(kernel,k+halfKernel);
            }
            subsref(tempOut,i,j) = temp/kernelSum;
        }
    }
    
    for(i=startRow; i<endRow; i++)
    {
        for(j=startCol; j<endCol; j++)
        {
            temp = 0;
            for(k=-halfKernel; k<=halfKernel; k++)
            {
                temp += subsref(tempOut,(i+k),j) * asubsref(kernel,k+halfKernel);
            }
            subsref(imageOut,i,j) = temp/kernelSum;
        }
    }
*/
#ifdef APPROXIMATE
    LVA_FUNCTION_RM(2 /* int */ ,&(imageIn->data[0]),&(imageIn->data[rows*cols]),1);
    LVA_FUNCTION_RM(5/*float*/ ,&(tempOut->data[0]),&(tempOut->data[rows*cols]),1);
    LVA_FUNCTION_RM(5/*float*/ ,&(imageOut->data[0]),&(imageOut->data[rows*cols]),1);
#endif
    /*
    fFreeHandle(tempOut);
    iFreeHandle(kernel);
    return imageOut;
    */
}
             

